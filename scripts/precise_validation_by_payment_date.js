#!/usr/bin/env node

const https = require('https');

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  console.error('‚ùå Missing required environment variables');
  process.exit(1);
}

const supabaseHeaders = {
  apikey: SUPABASE_SERVICE_ROLE_KEY,
  Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
  'Content-Type': 'application/json',
};

function makeRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const req = https.request(url, options, (res) => {
      let data = '';
      res.on('data', (chunk) => (data += chunk));
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          try {
            resolve(JSON.parse(data));
          } catch (e) {
            resolve(data);
          }
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`));
        }
      });
    });

    req.on('error', reject);
    req.end();
  });
}

function logWithTimestamp(message) {
  const timestamp = new Date().toLocaleString();
  console.log(`[${timestamp}] ${message}`);
}

async function validatePixByPaymentDate() {
  logWithTimestamp('üîç VALIDA√á√ÉO PIX JUNHO 2025 - POR DATA DE PAGAMENTO');
  logWithTimestamp('==================================================');
  logWithTimestamp('üéØ Valor esperado: R$ 193.214,00');
  logWithTimestamp('üìÖ Crit√©rio: paid_at entre 01/06/2025 e 30/06/2025');

  try {
    // Buscar TODAS as faturas PIX pagas em junho por DATA DE PAGAMENTO
    let allPixInvoices = [];
    let offset = 0;
    const limit = 1000;

    while (true) {
      const batch = await makeRequest(
        `${SUPABASE_URL}/rest/v1/iugu_invoices?select=id,total_cents,paid_cents,paid_at,payment_method,status&status=eq.paid&payment_method=eq.iugu_pix&paid_at=gte.2025-06-01&paid_at=lt.2025-07-01&limit=${limit}&offset=${offset}`,
        { headers: supabaseHeaders }
      );

      if (batch.length === 0) break;
      allPixInvoices.push(...batch);
      offset += limit;

      if (batch.length < limit) break;
    }

    const totalValue =
      allPixInvoices.reduce(
        (sum, invoice) => sum + (invoice.paid_cents || invoice.total_cents || 0),
        0
      ) / 100;
    const expectedValue = 193214;
    const difference = totalValue - expectedValue;
    const percentDiff = (difference / expectedValue) * 100;

    console.log('');
    console.log('üìä RESULTADOS PIX JUNHO (POR DATA DE PAGAMENTO):');
    console.log(`   üí≥ Total de faturas PIX: ${allPixInvoices.length.toLocaleString()}`);
    console.log(
      `   üí∞ Valor no Supabase: R$ ${totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
    );
    console.log(
      `   üéØ Valor esperado: R$ ${expectedValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
    );
    console.log(
      `   üìà Diferen√ßa: R$ ${Math.abs(difference).toLocaleString('pt-BR', { minimumFractionDigits: 2 })} (${percentDiff.toFixed(3)}%)`
    );

    if (Math.abs(percentDiff) <= 0.5) {
      console.log('   ‚úÖ PRECIS√ÉO: EXCELENTE (‚â§ 0.5% diferen√ßa)');
    } else if (Math.abs(percentDiff) <= 2) {
      console.log('   ‚ö†Ô∏è  PRECIS√ÉO: BOA (‚â§ 2% diferen√ßa)');
    } else {
      console.log('   ‚ùå PRECIS√ÉO: INADMISS√çVEL (> 2% diferen√ßa)');
    }

    return {
      found: totalValue,
      expected: expectedValue,
      difference: difference,
      percentDiff: percentDiff,
      count: allPixInvoices.length,
      acceptable: Math.abs(percentDiff) <= 0.5,
    };
  } catch (err) {
    console.error(`‚ùå Erro na valida√ß√£o PIX: ${err.message}`);
    return null;
  }
}

async function calculateMRRByPaymentDate(year, month, monthName) {
  logWithTimestamp('');
  logWithTimestamp(`üîç C√ÅLCULO MRR ${monthName.toUpperCase()} ${year} - POR DATA DE PAGAMENTO`);
  logWithTimestamp('='.repeat(50 + monthName.length));
  logWithTimestamp('üìÖ Crit√©rio: paid_at dentro do m√™s + refunded com data de cria√ß√£o no m√™s');

  try {
    const monthStr = month.toString().padStart(2, '0');
    const nextMonth = month === 12 ? 1 : month + 1;
    const nextYear = month === 12 ? year + 1 : year;
    const nextMonthStr = nextMonth.toString().padStart(2, '0');

    // Buscar faturas PAGAS no m√™s (por data de pagamento)
    let paidInvoices = [];
    let offset = 0;
    const limit = 1000;

    console.log(`üì• Buscando faturas pagas em ${monthName}/${year} (por data de pagamento)...`);

    while (true) {
      const batch = await makeRequest(
        `${SUPABASE_URL}/rest/v1/iugu_invoices?select=id,subscription_id,total_cents,paid_cents,status,paid_at&subscription_id=not.is.null&status=eq.paid&paid_at=gte.${year}-${monthStr}-01&paid_at=lt.${nextYear}-${nextMonthStr.padStart(2, '0')}-01&limit=${limit}&offset=${offset}`,
        { headers: supabaseHeaders }
      );

      if (batch.length === 0) break;
      paidInvoices.push(...batch);
      offset += limit;

      if (batch.length < limit) break;
    }

    // Buscar faturas REEMBOLSADAS criadas no m√™s
    let refundedInvoices = [];
    offset = 0;

    console.log(`üì• Buscando faturas reembolsadas criadas em ${monthName}/${year}...`);

    while (true) {
      const batch = await makeRequest(
        `${SUPABASE_URL}/rest/v1/iugu_invoices?select=id,subscription_id,total_cents,status,created_at_iugu&subscription_id=not.is.null&status=eq.refunded&created_at_iugu=gte.${year}-${monthStr}-01&created_at_iugu=lt.${nextYear}-${nextMonthStr.padStart(2, '0')}-01&limit=${limit}&offset=${offset}`,
        { headers: supabaseHeaders }
      );

      if (batch.length === 0) break;
      refundedInvoices.push(...batch);
      offset += limit;

      if (batch.length < limit) break;
    }

    // Calcular valores
    const paidValue =
      paidInvoices.reduce((sum, inv) => sum + (inv.paid_cents || inv.total_cents || 0), 0) / 100;
    const refundedValue =
      refundedInvoices.reduce((sum, inv) => sum + (inv.total_cents || 0), 0) / 100;
    const totalMRR = paidValue + refundedValue;

    // An√°lise por assinatura √∫nica
    const uniqueSubscriptions = new Set([
      ...paidInvoices.map((inv) => inv.subscription_id),
      ...refundedInvoices.map((inv) => inv.subscription_id),
    ]);

    console.log('');
    console.log(`üìä RESULTADOS MRR ${monthName.toUpperCase()} ${year}:`);
    console.log(
      `   ‚úÖ Faturas pagas (por data pagamento): ${paidInvoices.length.toLocaleString()} (R$ ${paidValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })})`
    );
    console.log(
      `   üîÑ Faturas reembolsadas (por data cria√ß√£o): ${refundedInvoices.length.toLocaleString()} (R$ ${refundedValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })})`
    );
    console.log(
      `   üí∞ MRR TOTAL: R$ ${totalMRR.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
    );
    console.log(
      `   üìã Assinaturas √∫nicas envolvidas: ${uniqueSubscriptions.size.toLocaleString()}`
    );
    console.log(
      `   üìä Valor m√©dio por assinatura: R$ ${(totalMRR / uniqueSubscriptions.size).toFixed(2)}`
    );

    // Top 10 assinaturas
    const subscriptionTotals = {};
    [...paidInvoices, ...refundedInvoices].forEach((inv) => {
      if (!subscriptionTotals[inv.subscription_id]) {
        subscriptionTotals[inv.subscription_id] = 0;
      }
      subscriptionTotals[inv.subscription_id] += (inv.paid_cents || inv.total_cents || 0) / 100;
    });

    const topSubscriptions = Object.entries(subscriptionTotals)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10);

    console.log('');
    console.log(`üèÜ TOP 10 ASSINATURAS ${monthName.toUpperCase()}:`);
    topSubscriptions.forEach(([subId, value], index) => {
      console.log(
        `   ${index + 1}. ${subId}: R$ ${value.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
      );
    });

    return {
      month: `${monthName}/${year}`,
      paid: { count: paidInvoices.length, value: paidValue },
      refunded: { count: refundedInvoices.length, value: refundedValue },
      total: { value: totalMRR, subscriptions: uniqueSubscriptions.size },
      topSubscriptions: topSubscriptions,
    };
  } catch (err) {
    console.error(`‚ùå Erro no c√°lculo MRR ${monthName}: ${err.message}`);
    return null;
  }
}

async function runPreciseValidation() {
  console.log('üéØ VALIDA√á√ÉO PRECISA POR DATA DE PAGAMENTO');
  console.log('==========================================');
  console.log('üìä Toler√¢ncia m√°xima: 0.5%');
  console.log('üìÖ Crit√©rio: Sempre usar paid_at para pagamentos');
  console.log('');

  const results = {};

  // Validar PIX junho por data de pagamento
  const pixResult = await validatePixByPaymentDate();
  if (pixResult) results.pix = pixResult;

  // Calcular MRR agosto (para confirmar)
  const mrrAugust = await calculateMRRByPaymentDate(2025, 8, 'agosto');
  if (mrrAugust) results.august = mrrAugust;

  // Calcular MRR fevereiro 2025
  const mrrFebruary = await calculateMRRByPaymentDate(2025, 2, 'fevereiro');
  if (mrrFebruary) results.february = mrrFebruary;

  // Resumo final
  console.log('');
  console.log('üéØ RESUMO FINAL:');
  console.log('================');

  if (results.pix) {
    const status = results.pix.acceptable ? '‚úÖ APROVADO' : '‚ùå REPROVADO';
    console.log(`üí≥ PIX Jun/2025: ${status} (${results.pix.percentDiff.toFixed(3)}%)`);
  }

  if (results.august) {
    console.log(
      `üìä MRR Ago/2025: R$ ${results.august.total.value.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} (${results.august.total.subscriptions} assinaturas)`
    );
  }

  if (results.february) {
    console.log(
      `üìä MRR Fev/2025: R$ ${results.february.total.value.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} (${results.february.total.subscriptions} assinaturas)`
    );
  }

  const allAcceptable = !results.pix || results.pix.acceptable;

  if (allAcceptable) {
    console.log('');
    console.log('üéâ VALIDA√á√ÉO APROVADA: Precis√£o dentro da toler√¢ncia!');
  } else {
    console.log('');
    console.log('‚ùå VALIDA√á√ÉO REPROVADA: Precis√£o fora da toler√¢ncia');
  }

  return results;
}

// Executar se chamado diretamente
if (require.main === module) {
  runPreciseValidation()
    .then((results) => {
      console.log('');
      console.log('‚úÖ Valida√ß√£o precisa conclu√≠da!');
      process.exit(0);
    })
    .catch((err) => {
      console.error(`üí• Erro fatal: ${err.message}`);
      process.exit(1);
    });
}

module.exports = { validatePixByPaymentDate, calculateMRRByPaymentDate, runPreciseValidation };
